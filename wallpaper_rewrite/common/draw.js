/**
        Â´Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆÂ´Â´Â´Â´Â´Â´Â´
        Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´Â´Â´Â´
        Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´Â´
        Â´Â´`Â´â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–ˆâ–ˆâ–ˆÂ´Â´Â´Â´Â´
        Â´Â´Â´â–ˆâ–ˆâ–ˆâ–’â—â–’â–’â—â–’â–ˆâ–ˆÂ´Â´Â´
        Â´Â´Â´â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–ˆâ–ˆÂ´Â´Â´Â´Â´
        Â´Â´Â´â–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–ˆâ–ˆÂ´                  
        Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–ˆâ–ˆâ–ˆÂ´Â´Â´Â´Â´               
        Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–ˆâ–ˆâ–ˆÂ´Â´                   
        â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–’â–’â–’â–’â–’â–’â–ˆâ–ˆâ–ˆÂ´Â´Â´Â´                
        Â´Â´â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’Â´Â´                 
        Â´Â´â–’â–’â–’â–’â–“â–“â–“â–“â–“â–“â–“â–“â–“â–’Â´Â´Â´Â´Â´              
        Â´.â–’â–’â–’Â´Â´â–“â–“â–“â–“â–“â–“â–“â–“â–’Â´Â´Â´Â´Â´             
        Â´.â–’â–’Â´Â´Â´Â´â–“â–“â–“â–“â–“â–“â–“â–’                 
        ..â–’â–’.Â´Â´Â´Â´â–“â–“â–“â–“â–“â–“â–“â–’               
        Â´â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’â–’                      
        Â´Â´Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´Â´Â´              
        Â´Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´Â´Â´Â´Â´
        Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´Â´Â´Â´
        Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´Â´             å¤§éƒ¨åˆ†äººéƒ½åœ¨å…³æ³¨ä½ é£çš„é«˜ä¸é«˜ï¼Œå´æ²¡äººåœ¨ä¹ä½ é£çš„ç´¯ä¸ç´¯ï¼Œè¿™å°±æ˜¯ç°å®ï¼
        Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´                     æˆ‘ä»ä¸ç›¸ä¿¡æ¢¦æƒ³ï¼Œæˆ‘ï¼Œåªï¼Œç›¸ï¼Œä¿¡ï¼Œè‡ªï¼Œå·±ï¼
        Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´
        Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´
        Â´Â´Â´Â´Â´Â´Â´Â´â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ´Â´Â´Â´Â´
        ________â–’â–’â–’â–’â–’
        _________â–’â–’â–’â–’
        _________â–’â–’â–’â–’
        ________â–’â–’_â–’â–’
        _______â–’â–’__â–’â–’
        _____ â–’â–’___â–’â–’
        _____â–’â–’___â–’â–’
        ____â–’â–’____â–’â–’
        ___â–’â–’_____â–’â–’
        â–ˆâ–ˆâ–ˆ____ â–’â–’
        â–ˆâ–ˆâ–ˆâ–ˆ____â–ˆâ–ˆâ–ˆ
        â–ˆ _â–ˆâ–ˆâ–ˆ_ _â–ˆ_â–ˆâ–ˆâ–ˆ
â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”å¥³ç¥ä¿ä½‘ï¼Œä»£ç æ— bugâ€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
**/


/**
 * Drawç±»
 * @param  {string} id canvasid
 * @param  {string} width å®½
 * @param  {string} height ç¨¿
 * @return {object}    åˆ›å»ºçš„ç±»
 */
/**
 API
 1.addText ç”»æ–‡æœ¬ï¼ˆå•è¡Œæ–‡æœ¬ï¼Œå•è¡Œçœç•¥ï¼Œå¤šè¡Œçœç•¥ï¼‰
 @param  {object} param  å‚æ•°æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¯¹è±¡å±æ€§è¯´æ˜å¦‚ä¸‹
 @return {object}    åˆ›å»ºçš„ç±»
  {
    "type": "text",//ç±»å‹ addæ–¹æ³•å¿…å¡«
    "text": "",//æ–‡æœ¬å†…å®¹ æ–‡æœ¬ç±»å‹å¿…å¡«
    "size": 10,//å­—ä½“å¤§å° é»˜è®¤10
    "family": "sans-serif",//å­—ä½“æ—å  é»˜è®¤sans-serif
    "weight": "normal",//å­—ä½“ç²—ç»†ã€‚ä»…æ”¯æŒ normal, bold é»˜è®¤normal
    "style": "",//å­—ä½“æ ·å¼ã€‚ä»…æ”¯æŒ italic, oblique, normal é»˜è®¤normal
    "color": "#000",//å­—ä½“é¢œè‰² é»˜è®¤#000
    "x":0, //ä½ç½®x é»˜è®¤0
    "y": 0,//ä½ç½®y é»˜è®¤0
    "maxWidth": 0,//ç»˜åˆ¶çš„æœ€å¤§å®½åº¦ å•è¡Œæ–‡æœ¬å¯ç”¨
    "hAlign": "left",//æ°´å¹³å¯¹é½æ–¹å¼å¯é€‰å€¼ 'left'ã€'center'ã€'right'  é»˜è®¤left
    "vAlign": "top",//å‚ç›´å¯¹é½æ–¹å¼å¯é€‰å€¼ 'top'ã€'bottom'ã€'middle'ã€'normal' é»˜è®¤top
    "width": 0,//æ–‡æœ¬å®½åº¦ æœ‰è®¾ç½®ä¸”å¤§äº0æ—¶å¼€å¯å¤šè¡Œæ–‡æœ¬
    "lineHeight": 1.2,//è¡Œé«˜  å¤šè¡Œæ–‡æœ¬æ—¶å¯ç”¨ é»˜è®¤ä¸ºå­—ä½“å¤§å°1.2å€ å½“lineHeight<å­—ä½“å¤§å°æ—¶è¡Œé«˜ç­‰äºlineHeight*å­—ä½“å¤§å°
    "lineClamp":1//è¡Œæ•°  å¤šè¡Œæ–‡æœ¬æ—¶å¯ç”¨  é™åˆ¶æœ€é«˜è¡Œæ•°,é»˜è®¤ä¸€è¡Œï¼Œé»˜è®¤æƒ…å†µä¸‹å¦‚æœæœ‰è®¾ç½®width ä¹Ÿå°±æ˜¯å•è¡Œçœç•¥
  }

  2.addImage ç”»å›¾ç‰‡ (æ™®é€šå›¾ç‰‡ åœ†è§’å›¾ç‰‡)
  @param  {object} param  å‚æ•°æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¯¹è±¡å±æ€§è¯´æ˜å¦‚ä¸‹
  @return {object}    åˆ›å»ºçš„ç±»
  {
    "type": "image",//ç±»å‹ addæ–¹æ³•å¿…å¡«
    "src":'',//å›¾ç‰‡è·¯å¾„ å¯ä»¥ä½¿ä¸´æ—¶è·¯å¾„ ç›¸å¯¹è·¯å¾„ ç½‘ç»œèµ„æº
    "defealtSrc":"",//srcé”™è¯¯æ—¶çš„é»˜è®¤å›¾
    "radiu": 0,//å›¾ç‰‡åœ†è§’ å¯ä»¥è®¾ç½®ä¸åŒçš„åŠå¾„ radiu:"20 30 20 30" æˆ–è€… "20 30"
    //ä»¥ä¸‹è¡¨ç¤ºåœ¨canvasä¸­çš„å®½é«˜
    "dx":0,
    "dy":0,
    "dw":"auto",//å®½åº¦  é»˜è®¤å›¾ç‰‡å®½åº¦
    "dh":"auto",//é«˜  é»˜è®¤å›¾ç‰‡é«˜åº¦
    //ä»¥ä¸‹è¡¨ç¤ºåœ¨åŸå›¾ä¸­æˆªå–ä¸€ä¸ªçŸ©å½¢,è€Œä¸æ˜¯å®Œæ•´çš„å›¾ç‰‡ï¼ˆé»˜è®¤å®Œæ•´å›¾ç‰‡ï¼‰å¹¶ä¸”ä¸ç®¡è®¾ç½®rpxè¿˜æ˜¯px  ä»¥ä¸Š4ä¸ªå•ä½éƒ½æ˜¯px
    "sy":0,
    "sx":0,
    "sw":"auto",
    "sh":"auto",
    "mode":"aspectFill" //å¯é€‰å€¼ 'scaleToFill'ã€'aspectFill'é»˜è®¤scaleToFill  å‚è€ƒå¾®ä¿¡å›¾ç‰‡ç»„ä»¶è¯´æ˜ widthFixå¯é€šè¿‡é«˜åº¦autoå®ç°
  }

  3.addLabel ç”»æ ‡ç­¾ 
  @param  {object} param  å‚æ•°æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œå¯¹è±¡å±æ€§è¯´æ˜å¦‚ä¸‹
  @return {object}    åˆ›å»ºçš„ç±»
  {
    "type": "label",//ç±»å‹ addæ–¹æ³•å¿…å¡«
    "label": "",//æ ‡ç­¾æ–‡å­— å¯ä»¥æ˜¯æ•°ç»„ è¡¨ç¤ºå¤šä¸ªæ ‡ç­¾ï¼Œç›¸åº”çš„ä¸€ä¸‹é¢œè‰²å±æ€§ä¹Ÿå¯ä»¥æ˜¯æ•°ç»„
    "size": 10,//æ ‡ç­¾å­—ä½“å¤§å° é»˜è®¤10
    "family": "sans-serif",//å­—ä½“æ—å  é»˜è®¤sans-serif
    "weight": "normal",//å­—ä½“ç²—ç»†ã€‚ä»…æ”¯æŒ normal, bold é»˜è®¤normal
    "style": "",//å­—ä½“æ ·å¼ã€‚ä»…æ”¯æŒ italic, oblique, normal é»˜è®¤normal
    "color": "#000",//å­—ä½“é¢œè‰² é»˜è®¤#000 å¯ä»¥æ˜¯æ•°ç»„
    "x": 0, //ä½ç½®x é»˜è®¤0
    "y": 0,//ä½ç½®y é»˜è®¤0
    "hAlign": "left",//æ°´å¹³å¯¹é½æ–¹å¼å¯é€‰å€¼ 'left'ã€'center'ã€'right'  é»˜è®¤left
    "vAlign": "top",//å‚ç›´å¯¹é½æ–¹å¼å¯é€‰å€¼ 'top'ã€'bottom'ã€'middle'ã€'normal' é»˜è®¤top
    "between":10,//æ ‡ç­¾ä¹‹é—´çš„è·ç¦» é»˜è®¤10
    "padding":20,//è¾¹æ¡†å’Œå­—ä½“ä¹‹é—´çš„ç¼–å‰§ é»˜è®¤20 '20 30'
    "borderColor":'#fff',//è¾¹æ¡†é¢œè‰² é»˜è®¤ç­‰äºå­—ä½“é¢œè‰² æ ¹æ®æ ‡ç­¾çš„æ•°é‡ å¯ä»¥æ˜¯æ•°ç»„
    "bgColor":"transparent",//é»˜è®¤ä¸ºé€æ˜ å³æ²¡æœ‰èƒŒæ™¯é¢œè‰² æ ¹æ®æ ‡ç­¾çš„æ•°é‡ å¯ä»¥æ˜¯æ•°ç»„
    "radiu":0 //åŠå¾„  "10 20" "10 20 30"
  }

  4.addCustom è‡ªå®šä¹‰æ–¹æ³•
  @param  {function} callback  å›è°ƒå‡½æ•°  å‡½æ•°å‚æ•°å¸¦æœ‰ctxï¼Œå¦‚æœæœ‰ç½‘ç»œå›¾ç‰‡ ç¬¬äºŒä¸ªå‚æ•°æ˜¯ç½‘ç»œå›¾ç‰‡èµ„æº
  @param  {array | string} url  è‡ªå®šä¹‰æ–¹æ³•é‡Œéœ€è¦ç”¨åˆ°çš„ç½‘ç»œå›¾ç‰‡ï¼Œé¢„åŠ è½½çš„å›¾ç‰‡èµ„æºä¼šå‡ºç°åœ¨å›è°ƒå‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°é‡Œ
  @return {object}    åˆ›å»ºçš„ç±»

  5.draw ç”»ï¼Œä½†æ˜¯ä¸å¯¼å‡ºå›¾ç‰‡
  @param  {boolean} æœ¬æ¬¡ç»˜åˆ¶æ˜¯å¦æ¥ç€ä¸Šä¸€æ¬¡ç»˜åˆ¶
  @return {object}    promiseå¯¹è±¡
  
  6.drawToImage ç”» å¯¼å‡ºå›¾ç‰‡
  @param  {boolean} æœ¬æ¬¡ç»˜åˆ¶æ˜¯å¦æ¥ç€ä¸Šä¸€æ¬¡ç»˜åˆ¶
  @param  {object} å¯¼å‡ºå›¾ç‰‡çš„ç›¸å…³å±æ€§ï¼Œè¯´æ˜çœ‹https://developers.weixin.qq.com/miniprogram/dev/api/canvas/temp-file.html
  {
    x: 100,
    y: 200,
    width: 50,
    height: 50,
    destWidth: 100,
    destHeight: 100,
  }
  @return {object}    promiseå¯¹è±¡

  7.rpx2px  rpxè½¬px
  @param  {number} rpx
  @return {number} px

  8.randomHexColoréšæœºé¢œè‰²
  @return {string} è¿”å›éšæœºé¢œè‰²
 */


// for (let ch of 'ğŸ¹ğŸ‚ğŸ¯ğŸ°ğŸ²ğŸğŸ´ğŸ‘ğŸ’ğŸ”') {
//   console.log(ch)
// }


wx._getImageInfo = function (src) {
  if (typeof src === "object") src = src.src;
  if (!src) return Promise.resolve(null);
  if (src.indexOf('//tmp') === -1) src = src.replace(/https?/, 'https');
  return new Promise((resolve, reject) => {
    this.getImageInfo({
      src,
      success: resolve,
      fail: reject
    })
  })
}

class Draw {
  constructor(id, unit) {
    this.ctx = wx.createCanvasContext(id);
    this.datas = [];
    this.preLoads = [];
    if (unit === "rpx") {
      this.unit = unit;
      this.windowWidth = wx.windowWidth || wx._getSystemInfoSync().windowWidth
    }
  }
  addText(param) {
    param.type = "text";
    this.datas.push(param);
    param = null;
    return this;
  }
  addImage(param) {
    var p = wx._getImageInfo(param.src);
    if (param.defealtSrc) {
      let defealtSrc = param.defealtSrc;
      p = p.catch(e => {
        return wx._getImageInfo(defealtSrc)
      })
    }
    param.type = "image";
    param.index = this.preLoads.length;
    this.preLoads.push(p);
    this.datas.push(param);
    param = null;
    return this;
  }
  addLabel(param) {
    param.type = "label";
    this.datas.push(param);
    param = null;
    return this;
  }
  addCustom(callback, src) {
    var param = {};
    param.type = "custom";
    param.fn = callback;
    param.index = this.preLoads.length;
    if (src) {
      if (typeof src === "string") {
        this.preLoads.push(wx._getImageInfo(src));
        param.len = 1;
      } else {
        src.forEach(item => {
          this.preLoads.push(wx._getImageInfo(item));
        })
        param.len = src.length;
        src = null;
      }
    }
    this.datas.push(param);
    return this;
  }
  draw(reserve = false) {
    if (this.preLoads.length > 0) {
      return Promise.all(this.preLoads).then(this.startDraw.bind(this, reserve))
    }
    return this.startDraw(reserve);
  }
  drawToImage(reserve = false, param = {}) {
    return this.draw(reserve).then(() => {
      
      return new Promise((resolve, reject) => {
        wx.canvasToTempFilePath({
          canvasId: this.ctx.canvasId,
          success: res => {
            param = null;
            resolve(res.tempFilePath);
          },
          fail: reject,
          ...param
        })
      })
    })
  }
  startDraw(reserve, imgs) {
    var datas = this.datas;
    this.datas = [];
    this.preLoads = [];
    datas.forEach(item => {
      switch (item.type) {
        case 'text':
          this.drawText(item);
          break;
        case "image":
          let { width, height, path } = imgs[item.index];
          item.src = path;
          item.width = width;
          item.height = height;
          this.drawImage(item);
          break;
        case "label":
          this.drawLabel(item);
          break;
        case "custom":
          if (item.len) {
            item.fn(this.ctx, imgs.slice(item.index, item.index + item.len))
          } else {
            item.fn(this.ctx)
          }
      }
    });
    return new Promise((resolve, reject) => {
      this.ctx.draw(reserve, resolve);
    })
  }
  drawLabel(param) {
    var {
      label = "",
      size = 10,
      family = "sans-serif",
      weight = "normal",
      style = "normal",
      color = "#000",
      x = 0,
      y = 0,
      hAlign = "left",
      vAlign = "top",
      between = 10,
      padding = 10,
      borderColor = color,
      bgColor = 'transparent',
      radiu = 0,
      randomColor = this.randomHexColor
    } = param,
      ctx = this.ctx,
      totalHeight,
      totalWidth = 0,
      pl, pr, pt, pb;
    param = null;
    if (typeof label === 'string') label = [label];
    if (color === 'r') {
      color = label.map(() => {
        return randomColor();
      })
      if (borderColor === "r") {
        borderColor = color;
      }
    }
    if (borderColor === 'r') {
      borderColor = label.map(() => {
        return randomColor();
      })
    }
    if (bgColor === 'r') {
      bgColor = label.map(() => {
        return randomColor();
      })
    }
    if (typeof color === 'string') color = [color];
    if (typeof borderColor === 'string') borderColor = [borderColor];
    if (typeof bgColor === 'string') bgColor = [bgColor];
    if (vAlign === "center") vAlign = "middle";
    if (this.unit === "rpx") {
      size = Math.round(this.rpx2px(size));
      x = this.rpx2px(x);
      y = this.rpx2px(y);
      between = this.rpx2px(between);
    }
    padding = this.__parseFour(padding);
    if (typeof padding === 'number') {
      pl = pr = pt = pb = padding;
    } else {
      [pt, pr, pb, pl] = padding;
      padding = null;
    }
    totalHeight = size + pt + pb;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    ctx.font = [style, weight, size + "px", family].join(' ');
    label = label.filter(item=>{
        if(item) return true;
        return false
    })
    label = label.map(item => {
      let left = totalWidth,
        w = pl + ctx.measureText(item).width + pr;
      totalWidth += w + between;
      return {
        left,
        w,
        h: totalHeight,
        text: item
      }
    })
    totalWidth -= between;

    switch (hAlign) {
      case "center":
        x -= totalWidth / 2;
        break;
      case "right":
        x -= totalWidth;
        break;
    }
    switch (vAlign) {
      case "middle":
        y -= totalHeight / 2;
        break;
      case "bottom":
        y -= totalHeight;
    }
    radiu = this.__parseFour(radiu);
    label.forEach((item, index) => {
      let bg = bgColor[index] || bgColor[0];
      if (bg === 'transparent') {
        ctx.setStrokeStyle(borderColor[index] || borderColor[0])
      } else {
        ctx.setFillStyle(bg)
      }
      if (radiu == 0) {
        ctx.rect(x + item.left, y, item.w, item.h)
      } else {
        this.__drawRadiuRect(x + item.left, y, item.w, item.h, radiu)
      }
      
      if (bg === 'transparent') {
        ctx.stroke()
      } else {
        ctx.fill()
      }
      ctx.setFillStyle(color[index] || color[0]);
      ctx.fillText(item.text, x + item.left + pl, y + pt + size / 2);
    })

    label = randomColor = color = bgColor = bgColor = null;
  }
  drawImage(param) {
    var {
      src,
      radiu = 0,
      width,
      height,
      dx = 0,
      dy = 0,
      dw = "auto",
      dh = "auto",
      sy = 0,
      sx = 0,
      sw = "auto",
      sh = "auto",
      mode = "aspectFill",
      hAlign = 'left',
      vAlign = 'top'
    } = param,
      ctx = this.ctx;
    param = null;
    if (sw === "auto" && sh === "auto") {
      sw = width; sh = height;
    } else if (sw === "auto") {
      sw = width / height * sh;
    } else if (sh === 'auto') {
      sh = height / width * sw;
    }
    if (this.unit === "rpx") {
      dx = this.rpx2px(dx);
      dy = this.rpx2px(dy);
      dw = this.rpx2px(dw);
      dh = this.rpx2px(dh);
    }
    
    if (dw === "auto" && dh === "auto") {
      dw = sw; dh = sh;
    } else if (dw === "auto") {
      dw = sw / sh * dh;
    } else if (dh === 'auto') {
      dh = sh / sw * dw;
    } else if (mode !== 'scaleToFill') {
      let dr = dw / dh,
        sr = sw / sh,
        temp;
      if (sr > dr) {//åŸå›¾åƒæ›´å®½   é«˜åº¦ä¸å˜  å®½åº¦åŠsxæ”¹å˜
        temp = dw / dh * sh;
        sx += (sw - temp) / 2;
        sw = temp;
      } else {//åŸå›¾åƒæ›´é«˜   å®½åº¦ä¸å˜  é«˜åº¦åŠsyæ”¹å˜
        temp = dh / dw * sw;
        sy += (sh - temp) / 2;
        sh = temp;
      }
    }
    if (vAlign === "center") vAlign = "middle";
    switch (hAlign) {
      case "center":
        dx -= dw / 2
        break;
      case "right":
        dx -= dw
        break;
    }
    switch (vAlign) {
      case "middle":
        dy -= dh / 2
        break;
      case "bottom":
        dy -= dh
    }
    if (radiu == 0) {
      // console.log(src, sx, sy, sw, sh, dx, dy, dw, dh)
      return ctx.drawImage(src, dx, dy, dw, dh);
    }
    ctx.save()
    this.__drawRadiuRect(dx, dy, dw, dh, this.__parseFour(radiu))
    ctx.clip();
    
    ctx.drawImage(src, dx, dy, dw, dh);
    ctx.restore()
  }
  __drawRadiuRect(x, y, w, h, r) {
    var rtl, rtr, rbl, rbr, shortestHalf = Math.min(w, h) / 2, isCircle = false, ctx = this.ctx;
    if (Array.isArray(r)) {
      ([rtl, rtr, rbr, rbl] = r);
      r = null;
    } else {
      if (r >= shortestHalf) {
        isCircle = true;
        r = shortestHalf;
      } else {
        rtl = rtr = rbl = rbr = r;
      }
    }
    if (isCircle) {
      ctx.arc(x + r, y + r, r, 0, 2 * Math.PI);
    } else {
      ctx.beginPath()
      ctx.moveTo(x, y + rtl);
      ctx.arc(x + rtl, y + rtl, rtl, Math.PI, 1.5 * Math.PI);//å·¦ä¸Šè§’åœ†è§’
      ctx.lineTo(x + w - rtr, y);
      ctx.arc(x + w - rtr, y + rtr, rtr, 1.5 * Math.PI, 0)//å³ä¸Šè§’åœ†è§’
      ctx.lineTo(x + w, y + h - rbr);
      ctx.arc(x + w - rbr, y + h - rbr, rbr, 0, 0.5 * Math.PI)//å³ä¸‹è§’åœ†è§’
      ctx.lineTo(x + rbl, y + h);
      ctx.arc(x + rbl, y + h - rbl, rbl, 0.5 * Math.PI, Math.PI)//å·¦ä¸‹è§’åœ†è§’
      ctx.closePath();
    }
  }
  __parseFour(value) {
    if (typeof value === "string" && !Number(value)) {
      value = value.split(' ').map(item => {
        if (this.unit === "rpx") item = this.rpx2px(item)
        else {
          item = Number(item);
        }
        return item;
      });
      value[2] = value[2] || value[0];
      value[3] = value[3] || value[1];
    } else {
      if (this.unit === "rpx") value = this.rpx2px(value);
      else {
        value = Number(value);
      }
    }
    return value;
  }
  drawText(param) {
    var {
      text = "",
      size = 10,
      family = "sans-serif",
      weight = "normal",
      style = "normal",
      color = "#000",
      x = 0,
      y = 0,
      maxWidth,
      hAlign = "left",
      vAlign = "top",
      width = 0,
      lineHeight = 1.2 * size,
      lineClamp = 0
    } = param,
      ctx = this.ctx;
    param = null;
    text = text.replace(/\n+/g,'');
    if (lineHeight < size) {
      lineHeight = lineHeight * size;
    }
    if (this.unit === "rpx") {
      size = Math.round(this.rpx2px(size));
      x = this.rpx2px(x);
      y = this.rpx2px(y);
      maxWidth = this.rpx2px(maxWidth);
      width = this.rpx2px(width);
      lineHeight = this.rpx2px(lineHeight);
    }
    if (vAlign === "center") vAlign = "middle";
    ctx.font = [style, weight, size + "px", family].join(' ');
    ctx.fillStyle = color;
    if (!width) {
      ctx.textAlign = hAlign;
      ctx.textBaseline = vAlign;
      ctx.fillText(text, x, y, maxWidth);
      return;
    }
    width = Math.max(width, size * 2);
    var rows = [], temp = "", isExceed = false, height = 0;
    
    for (var ch of text) {//å¿…é¡»ä½¿ç”¨for ofå¾ªç¯
      if (ctx.measureText(temp + ch).width > width) {
        rows.push(temp);
        temp = ch;
        if (lineClamp > 0 && rows.length >= lineClamp) {
          temp = '';
          isExceed = true;
          break;
        }
      } else {
        temp += ch;
      }
    }
    if (temp.length > 0) {
      rows.push(temp);
    }
    if (isExceed) {//è¶…å‡º
      let lastRow = rows[rows.length - 1];
      for (ch of lastRow) {
        if (ctx.measureText(temp + ch + '...').width > width) {
          break;
        } else {
          temp += ch;
        }
      }
      rows[rows.length - 1] = temp + '...';
    }
    height = lineHeight * rows.length;
    if (lineClamp > 0 && rows.length === 1) width = ctx.measureText(rows[0]).width
    ctx.textAlign = 'left';
    ctx.textBaseline = 'middle';
    switch (hAlign) {
      case "center":
        x -= width / 2;
        break;
      case "right":
        x -= width;
        break;
    }
    switch (vAlign) {
      case "top":
        y += lineHeight / 2;
        break;
      case "middle":
        y = y - height / 2 + lineHeight / 2;
        break;
      case "bottom":
        y = y - height + lineHeight / 2;
    }
    rows.forEach((item, index) => {
      ctx.fillText(item, x, y + index * lineHeight);
    })
    rows = null;
  }
  rpx2px(rpx) {
    if (!rpx || rpx === 'auto') return rpx;
    return this.windowWidth / 750 * rpx;
  }
  randomHexColor() { //éšæœºç”Ÿæˆåå…­è¿›åˆ¶é¢œè‰²
    return '#' + ('00000' + (Math.random() * 0x1000000 << 0).toString(16)).substr(-6);
  }
}

// wx.Draw = Draw;
export default Draw